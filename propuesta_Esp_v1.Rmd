---
title: "Trabajo Especializacion V1.0.0"
author: "Ignacio Chiapella"
output:
  html_document:
    df_print: paged
    toc: yes
  html_notebook:
    df_print: paged
    theme: spacelab
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
---

<style type="text/css">
div.main-container {
  max-width: 1600px;
  margin-left: auto;
  margin-right: auto;
}
</style>

## Librerias
```{r message=FALSE, warning=FALSE}
# library(tidyverse)
# library(ggthemes)
# library(corrr)
# library(plyr)
# library(mongolite)
# library(ggmap)
# library(dplyr)
# library(sp)
# library(lubridate)
# library(tidyr)
# library(reshape2)
# library(stringr)
# library(GGally)
# library(modelr)
library(cluster)
library(broom)
library(glmnet)
library(modelr)
library(ggplot2)
library(cowplot)



library(mongolite)
library(ggmap)
library(dplyr)
library(sp)
library(lubridate)
library(tidyr)
library(reshape2)
library(stringr)
```

## Load de datos desde MongoDb
```{r}
#register_google(key = "AIzaSyDNEh_BUnqoTTsABfuSB_BftOm5fvlHpuw")

sucursales_mongo <- mongo(collection = "sucursales", db = "precios_caba")
sucursales <- sucursales_mongo$find()
productos <- mongo(collection = "productos", db = "precios_caba")$find()
precios <- mongo(collection = "precios", db = "precios_caba")$find()
barrios <- mongo(collection = "barrios", db = "precios_caba")
dolar <- mongo(collection = "dolar", db = "precios_caba")$find()
inflacion <- mongo(collection = "inflacion", db = "precios_caba")$find()
```
Se cargan desde la base MongoDB los siguientes ds:

- sucursales

- productos

- precios

- barrios

- dolar

- inflasion

TODO: incluir DER


## Enriquecimiento y filtrado de datos Sucursales
```{r}
# seleccionar_barrio <- function(los_barrios, la_sucursal) {
#   query <- paste0('{"geometry": {"$near": {"$geometry": {"type": "Polygon", "coordinates":[',la_sucursal['lng'],',',la_sucursal['lat'],']}}}}')
#   
#   return (los_barrios$find(query, limit=1)$properties$BARRIO)
# }

# me quedo unicamente con las sucursales que tienen datos de precios informados
#sucursales_con_datos = filter(sucursales, id %in% distinct(precios, sucursal)$sucursal)

## ****Agrego las sucursales el barrio de pertenencia****
#barrios_sucursales = apply(sucursales_con_datos, 1, seleccionar_barrio, 
#los_barrios=barrios)
#sucursales_con_datos$barrio <- barrios_sucursales

sucursales_con_datos <- mongo(collection = "sucursales_con_datos", db = "precios_caba")$find()


```

Se enrriquece la informacion de las sucursales con la informacion de en que barrio esta localizada cada una.

## Enriquecimiento datos del valor del DOLAR
```{r}
# Transforma los datos de los valores del dolar
agrupar_valores_dolar <- function(dolar_valores, intervalo) {
  dolar_por_fecha = group_by(dolar, fecha=floor_date(fecha, intervalo))
  dolar_media = summarize(dolar_por_fecha, compra=mean(compra), venta=mean(venta))
  compra=select(dolar_media, compra, fecha)
  compra$fecha=as.Date(compra$fecha, format="%m/%d/%y")
  compra$operacion="compra"
  colnames(compra)[which(names(compra) == "compra")] = "valor"
  venta=select(dolar_media, venta, fecha)
  venta$operacion="venta"
  venta$fecha=as.Date(venta$fecha, format="%m/%d/%y")
  colnames(venta)[which(names(venta) == "venta")] = "valor"
  
  return(rbind(compra, venta))
}
# Se generan distintos cortes del valor del dolar para luego comparar
dolar_7_dias = agrupar_valores_dolar(dolar, "7 days")
dolar_15_dias = agrupar_valores_dolar(dolar, "15 days")
dolar_1_mes = agrupar_valores_dolar(dolar, "1 month")

# Formateo la fecha
inflacion$fecha=as.Date(inflacion$fecha, format="%m/%d/%y")
```

Se generan funciones de corte, para poder tener agrupaciones del valor de la moneda norteamericana en pasos de 1, 7 y 15 dias.

## Revison de variables en PRECIOS
```{r}
glimpse(precios)
rbind(valores_unicos=sapply(precios, function(x) length(unique(x))), valores_na=sapply(precios, function(x) sum(is.na(x))))
```

Se desprende de esta analisis que se cuenta con 1000 productos, los cuales estan repartidos entre 175 sucursales generando un total de 4792 mediciones.

No se observan datos faltantes en este ds.


## Revison de variables en PRODUCTOS
```{r}
glimpse(productos)
rbind(valores_unicos=sapply(productos, function(x) length(unique(x))), valores_na=sapply(productos, function(x) sum(is.na(x))))
```
Se evidencia un total de 1000 productos, agrupados en 293 marcas y 208 presentaciones.


## Revison de variables en SUCURSALES
```{r}
glimpse(sucursales_con_datos)
rbind(valores_unicos=sapply(sucursales_con_datos, function(x) length(unique(x))), valores_na=sapply(sucursales_con_datos, function(x) sum(is.na(x))))
```

De este estudio se desprende que contamos con 2 tipos de sucursal, 11 nombres de empresas/razon social y los 42 barrios de la Ciudad de Buenos Aires.


## Analisis de datos atípicos (outliers)
### Variable PRECIO



Se genera un primer grafico muy basico, para estudiar la distribucion de los precios durante el periodo de estudio.

```{r, fig.width=8,fig.height=8}
# Box plot para la variable precio
#boxplot(sort(precios$precio, decreasing = FALSE))
# Give the chart file a name.
#png(file = "/home/ignacio/datos/facultad/repos/tpEspecializacion/informe/img/boxplot_basico.png")

boxplot(sort(precios$precio, decreasing = FALSE),
  main = "Analisis de la variable precio",
  #xlab = "Parts Per Billion",
  ylab = "Precio",
  col = "gold",
  border = "brown",
  horizontal = FALSE,
  varwidth = TRUE,
  notch = TRUE
)

# Save the file.
#dev.off()

```

```{r}
# Calculo de cuantiles y rango intercuartil
cuantiles<-quantile(precios$precio, c(0.25, 0.5, 0.75), type = 7)
riq = cuantiles[3] - cuantiles[1]
outliers_min<-as.numeric(cuantiles[1])-1.5*riq
outliers_max<-as.numeric(cuantiles[3])+1.5*riq
#boxplot(sort(precios$precio[precios$precio>outliers_min & precios$precio<outliers_max], decreasing = FALSE))
```

Se calculan los cuantiles y el rango intercuartil, para acotar los datos y estudiar cuantos datos quedan fuera de estos limites.

```{r, fig.width=8,fig.height=8}
# Box plot para los precios dentro del rango intercuartil, se siguen observando outliers con precios altos

#png(file = "/home/ignacio/datos/facultad/repos/tpEspecializacion/informe/img/boxplot_acotado1.png")

boxplot(sort(precios$precio[precios$precio>outliers_min & precios$precio<outliers_max], decreasing = FALSE),
  main = "Analisis de la variable precio acotado 1",
  #xlab = "Parts Per Billion",
  ylab = "Precio",
  col = "gold",
  border = "brown",
  horizontal = FALSE,
  varwidth = TRUE,
  notch = TRUE
)

# Save the file.
#dev.off()

```

```{r, fig.width=8,fig.height=8}
# Calculo el desvio para ver la existencia de outliers con datos hasta 3 veces mayores o menores
desvio<-sd(precios$precio)
outliers_min_sd<-as.numeric(cuantiles[1])-3*desvio
outliers_max_sd<-as.numeric(cuantiles[3])+3*desvio
#boxplot(sort(precios$precio[precios$precio>outliers_min_sd & precios$precio<outliers_max_sd], decreasing = FALSE))

#png(file = "/home/ignacio/datos/facultad/repos/tpEspecializacion/informe/img/boxplot_acotado2.png")

boxplot(sort(precios$precio[precios$precio>outliers_min_sd & precios$precio<outliers_max_sd], decreasing = FALSE),
  main = "Analisis de la variable precio acotado 2",
  #xlab = "Parts Per Billion",
  ylab = "Precio",
  col = "gold",
  border = "brown",
  horizontal = FALSE,
  varwidth = TRUE,
  notch = TRUE
)

# Save the file.
#dev.off()


```

```{r}
# La cantidad de precios tomados mayores que el máximo outlier permitido
nrow(precios%>%filter(precio>outliers_max))*100/nrow(precios)
nrow(precios%>%filter(precio>outliers_max_sd))*100/nrow(precios)

```

```{r, fig.width=8,fig.height=8}
# Teniendo en cuenta los outliers con respecto a 3 veces la media, grafico box plot solo con esos precios
precios_mayores_desvio = precios%>%filter(precio>outliers_max_sd)
#boxplot(sort(precios_mayores_desvio$precio, decreasing = FALSE))

#png(file = "/home/ignacio/datos/facultad/repos/tpEspecializacion/informe/img/boxplot _mayor290.png")

boxplot(sort(precios_mayores_desvio$precio, decreasing = FALSE),
  main = "Analisis de la variable de precios con valores mayores a $290 ",
  #xlab = "Parts Per Billion",
  ylab = "Precio",
  col = "gold",
  border = "brown",
  horizontal = FALSE,
  varwidth = TRUE,
  notch = TRUE
)

# Save the file.
#dev.off()
```


Como conclusion por ahora, lo que se desprende de este analisis es que hay un grupo pequeño de datos con precios por arriba del bigote superior que no se corresponden a datos mal tomados sino a productos que su valor dista la generalidad de los precios.

Sin embargo por ahora seguiremos trabajando con todos los datos.



## ANALISIS EXPLORATORIO PRECIO
### Estadisticas descriptivas para la variable precio (cuartiles, promedio, minimo y maximo) 
```{r}
precio = precios$precio
summary(precio)
```

### Histograma de la variable precio
````{r, fig.width=10,fig.height=10}
ggplot(precios,aes(precio))+
      geom_histogram(bins = 40, ggplot2::aes(y=..density..), colour="black", fill="green")+ggtitle("Distribución de precios de los productos")

```
En cuanto al grafico del histograma, se puede evidenciar claramente una asimetria a derecha. Como se menciono antes, la gran mayoria de los precios de los productos poseen un valor menor a 200 pesos.

### Enrriquecimiento del data set precios con los datos de las sucursales
```{r}
precios_orig <- precios
precios <- inner_join(precios_orig, sucursales_con_datos[ , c("barrio","sucursalTipo","banderaDescripcion","id")], by=c("sucursal" = "id"), all.x=TRUE)
```


```{r}
glimpse(precios)
```


### Cuantiles de la variable precio agrupados por sucursal
```{r}
precios %>% 
  group_by(sucursal) %>%
  summarise(priceMean=mean(precio),priceMax=max(precio), priceMin=min(precio), price_1Q=quantile(precio, 0.25),priceMediann= quantile(precio, 0.5),price_3Q=quantile(precio, 0.75))
```


### Grafico de boxplot de la variable precio por sucursal
### TODO: Hacer un analisis de los supermercados en los que esten publicados la mayor cantidad de productos
````{r, fig.width=10,fig.height=10}
  ggplot(precios,
      aes(banderaDescripcion, precio, group=banderaDescripcion, fill = factor(banderaDescripcion))) + 
      geom_boxplot(alpha= 0.75) +
      ggtitle("precio vs banderaDescripcion")+
      labs(fill = "sucursal", x = "banderaDescripcion", y = "Price ($)") +
      theme(text = element_text(size=18), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```


### Aplico ZOOM en las cajas
```{r, fig.width=10,fig.height=10}
  ggplot(precios,
       aes(banderaDescripcion, precio, group=banderaDescripcion, fill = factor(banderaDescripcion))) + 
       geom_boxplot(alpha= 0.75) + 
       coord_cartesian(ylim = c(20, 120))+
       ggtitle("precio vs banderaDescripcion con Zoom")+
       theme(text = element_text(size=18), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
       labs(fill = "sucursal", x = "banderaDescripcion", y = "Price ($)")

```
Desprendemos del analisis de precios por razon social que tanto Jumbo como Disco poseen los limites superiores de las cajas similares, ademas de las medianas mas altas y casi iguales, esto probablemente se deba a que ambos supermercardos pertenencen a la misma empresa.


### Correlograma: Por ahora no aplica
```{r}

# precios  %>%
#   select(-producto, -sucursal) %>%
#   ggpairs(.,
#         title = "Matriz de correlaciones",
#         mapping = aes(colour= property_type))
```

## ANALISIS EXPLORATORIO SUCURSALES x BARRIO
### Razon social por barrio
```{r}
# count(sucursales_con_datos, "barrio")
# count(sucursales_con_datos, "sucursalTipo")
# count(sucursales_con_datos, "banderaDescripcion")
```


```{r}
analisisBarrios = sucursales_con_datos[ , c("barrio","sucursalTipo","banderaDescripcion")]
analisis_Barrios = analisisBarrios %>% group_by(barrio) %>% tally() %>% arrange(desc(n)) 
analisis_Bandera = analisisBarrios %>% group_by(banderaDescripcion) %>% tally() %>% arrange(desc(n)) 
```

```{r, fig.width=10,fig.height=10}
# factor
analisis_Barrios$barrio <- factor(analisis_Barrios$barrio, levels = analisis_Barrios$barrio[order(analisis_Barrios$n)])

ggplot(data=analisis_Barrios, aes(x=barrio, y=n)) +
  geom_bar(stat = "identity", aes(fill = n), position = "dodge")+
  xlab("Barrio") + ylab("Cantidad") +
  ggtitle("Cantidad de locales por barrio") +
  theme(text = element_text(size=18), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```

Se observa una asimetria a izquierda, teniendo 5 barrios de 42 el 44% del total de las sucursales y solo PALERMO presenta el 13% de las mismas.

```{r, fig.width=10,fig.height=10}
# Stacked
# lock in factor level order
analisis_Bandera$banderaDescripcion <- factor(analisis_Bandera$banderaDescripcion, levels = analisis_Bandera$banderaDescripcion[order(analisis_Barrios$n)])


ggplot(data=analisis_Bandera, aes(x=banderaDescripcion, y=n)) +
  geom_bar(stat = "identity", aes(fill = n), position = "dodge")+
  xlab("Barrio") + ylab("Cantidad") +
  ggtitle("Cantidad de locales por Razon Social") +
  theme(text = element_text(size=18), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```
```{r, fig.width=10,fig.height=10}

library(formattable)
#formattable(analisis_Bandera)

formattable(analisis_Bandera, 
            align =c("l","c"), 
            list(`Indicator Name` = formatter(
              "span", style = ~ style(color = "grey",font.weight = "bold")) 
))
#analisis_Bandera
```
Se observa claramente que en la ciudad de Buenos Aires la bandera COTO CICSA una predominancia de un casi el 40% de los locales de venta.

## Analisis comparativo de la variable PRECIO

### Enriquecimiento de los data set
```{r}
precios_barrio_sucursal = left_join(precios_orig, sucursales_con_datos, by=c("sucursal" = "id"))%>%select(producto, precio, sucursalTipo, barrio, fecha, comercioRazonSocial)
precios_barrio_sucursal$fecha=as.Date(precios_barrio_sucursal$fecha, format="%m/%d/%y")
precios_barrio = precios_barrio_sucursal%>%group_by(barrio, fecha=floor_date(fecha, "15 days"))%>%summarize(precio=mean(precio))
precios_sucursal_tipo = precios_barrio_sucursal%>%group_by(sucursalTipo, fecha=floor_date(fecha, "15 days"))%>%summarize(precio=mean(precio))
precios_cadena = precios_barrio_sucursal%>%group_by(comercioRazonSocial, fecha=floor_date(fecha, "15 days"))%>%summarize(precio=mean(precio))
```

### Grafico de la media de todos los precios agrupados por barrio con un corte cada 15 dias
```{r, fig.width=15,fig.height=10}
ggplot(precios_barrio, aes(x=fecha, y=precio, group=barrio)) +
  geom_line(aes(colour=barrio)) +
  geom_point(aes(colour = barrio), size = 1)
```

Para analizar si hay diferencia entre los precios promedios en el tiempo en los distintos barrios se realizo un diagrama que muestra la evolucion de los precios. En donde si bien no se puede desprender un analisis fino sobre los barrios (debido a la gran cantidad de barrios que se encuentran) si se evidencia que la tendencia es claramente al alza.




```{r, fig.width=10,fig.height=8}
# Grafico de la media de todos los precios agurpados por barrio

precios_barrio_total <- precios_barrio_sucursal%>%group_by(barrio)%>%summarize(precio=mean(precio))
precios_barrio_total$barrio <- factor(precios_barrio_total$barrio, levels = precios_barrio_total$barrio[order(precios_barrio_total$precio)])


ggplot(data=precios_barrio_total, aes(x=barrio, y=precio)) +
  geom_bar(stat = "identity", aes(fill = precio), position = "dodge")+
  xlab("Barrio") + # ylab("Precio promedio") +
  ggtitle("Precio promedio por barrio") +
  theme(text = element_text(size=18), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))



```

### Grafico de la media de todos los precios agrupados por tipo de sucursal
```{r, fig.width=8,fig.height=6}
# Grafico de la media de todos los precios agurpados por tipo de sucursal
ggplot(precios_sucursal_tipo, aes(x=fecha, y=precio, group=sucursalTipo)) +
  geom_line(aes(colour=sucursalTipo)) +
  geom_point(size = 1, aes(colour = sucursalTipo)) +
  #stat_smooth(aes(x = fecha, y = precio), method = "lm", formula = y ~ poly(x, 4), se = TRUE) +
  ylab('Precio medio')+xlab('Fecha') +
  labs(colour = "Tipo de sucursal") +
  labs(title="Precios medio por tipo de sucursal")
```


Para identificar si los precios varían entre los diferentes tipos de sucursales de las cadenas de los locales, agrupamos las mediciones de los productos por tipo de sucursal y por período de tiempo de 15 días, para finalmente tomar el valor medio de éstos productos.

Se observa que la variación en promedio de los precios no se ve reflejada por el tipo o tamaño la sucursal, si bien se aprecia que los hipermercados tienen en la mayoria de los casos un precio algo superior al de los Supermercados.


### Grafico de la media de todos los precios agrupados por razon social/cadena
```{r, fig.width=12,fig.height=8}
# Grafico de la media de todos los precios agrupados por cadena
ggplot(precios_cadena, aes(x=fecha, y=precio, group=comercioRazonSocial)) +
  geom_line(size = 1, aes(colour=comercioRazonSocial)) +
  geom_point(size = 2, aes(colour = comercioRazonSocial)) +
  #stat_smooth(aes(x = fecha, y = precio), method = "lm", formula = y ~ poly(x, 4), se = TRUE) +
  ylab('Precio medio')+xlab('Fecha') +
  labs(colour = "Cadena") +
  labs(title="Precios medio por cadena")
```

Se puede evidenciar que las cadenas de supermercado tienen precios claramente diferentes en promedio, desprendiendose JUMBO y COTO como las mayores y mas notorias. El resto de las cadenas si bien la tendencia siembre fue el aumento de precios, presentaron un comportamiento mas irregular.


### Grafico de la media de todos los precios vs inflasion y dolar
```{r, fig.width=12,fig.height=8}
# Grafico de la evolucion del precio del dolar y la inflacion
ggplot() + geom_line(aes(x=inflacion$fecha, y=inflacion$porcentaje, colour="Inflacion")) +
  geom_line(size = 1,aes(x=dolar_1_mes$fecha, y=dolar_1_mes$valor, group=dolar_1_mes$operacion, colour=dolar_1_mes$operacion)) +
  ylab('Valores')+xlab('Fecha') +
  labs(colour = "Referencia") +
  labs(title="Comparativa de las curvas de variacion del dolar y la inflacion mes a mes")
```



## Modelo lineal
```{r}
# medicion - barrio - sucursalTipo - banderaDescripcion
mcuadrado <- read.csv(file = '/home/ignacio/datos/facultad/repos/tpEspecializacion/data/barrioMetroCuadrado.csv')
#mcuadrado


summary(mcuadrado$mCuadrado)
```
Puedo decir que si el precio es menor que 1Q lo catalogo como bajo, si esta entre el 1Q y el 3Q es medio y si es superior al 3Q es alto.

```{r}
summary(analisis_Barrios$n)
```

```{r}
# Genero la nueva variable y redondeo el valor de los Qs.
analisis_Barrios$cantPtosVenta = cut(x = analisis_Barrios$n, breaks = c(0,1,5,23), labels=c("bajo","medio","alto"))
mcuadrado$mCuadradoC = cut(x = mcuadrado$mCuadrado, breaks = c(0,2250,3003,6681), labels=c("bajo","medio","alto"))
mcuadrado
analisis_Barrios
```

Left join con los datos del data set original, para incluir estas nuevas variables en el data set original haciendo un Join por barrio.

```{r}
#precios_barrio_sucursal = left_join(precios_orig, sucursales_con_datos, by=c("sucursal" = "id"))%>%select(producto, precio, sucursalTipo, barrio, fecha, comercioRazonSocial)
#barriosCategoricos = analisis_Barrios %>% left_join(mcuadrado)
barriosCategoricos = inner_join(mcuadrado,analisis_Barrios , by="barrio")%>%select(barrio, mCuadradoC, pVentasC)
preciosModelo = inner_join(precios,barriosCategoricos , by="barrio")
preciosModelo
```

### Modelo lineal simple para explicar el precio en función de la bandera supermercado
```{r}
# banderaDescripcion + medicion + barrio + banderaDescripcion + pVentasC + mCuadradoC
lm_precio2bandera = lm(formula = precio~banderaDescripcion, data=preciosModelo)
lm_precio2medicion = lm(formula = precio~medicion, data=preciosModelo)
#lm_precio2barrio = lm(formula = precio~barrio, data=precios)
```

###  Analisis de precio por Barrio
```{r}
summary(lm_precio2bandera)
#coef(lm_precio2bandera)
```
```{r}
summary(lm_precio2medicion)

```




```{r}
glance(lm_precio2bandera)
glance(lm_precio2medicion)
```



```{r}
# banderaDescripcion + sucursalTipo + medicion + pVentasC + mCuadradoC
lm_precioMultiple = lm(precio ~ banderaDescripcion + sucursalTipo + medicion + pVentasC + mCuadradoC , data=preciosModelo)
```

```{r}
# medicion - barrio - sucursalTipo - banderaDescripcion
summary(lm_precioMultiple)
```

### Analisis modelo compuesto
#### Analisis Residuo

```{r}
precioMultiple_resid = augment(lm_precioMultiple)
precioMultiple_resid
```

```{r}
#El promedio de los residuos debe ser un numero muy cercano a cero
mean(precioMultiple_resid$.resid)
```

Como se puede apreciar el valor obtenido del promedio de todos los residuos, es un numero cercano a cero.

```{r, fig.width=8,fig.height=8}
ggplot(precioMultiple_resid, aes(precioMultiple_resid$.resid)) + 
  geom_freqpoly(binwidth = 1.5)+
  labs(fill = "precioMultiple_resid$.resid", title = "Poligono de frecuencia de los residuos", x = "Residuo", y = "count")
```

```{r, fig.width=8,fig.height=8}

ggplot(precioMultiple_resid, aes(sample= .std.resid))+
  stat_qq()+
  geom_abline()+
  labs(title = "Normal QQ plot", x = "Valores teóricos", y = "Residuos estandarizados")

```

Se quiere validar, si los residuos siguien una distribucion teorica, N(0,1).
Como podemos ver el modelo en los extremos tiende a alejarse de la distribucion Normal, por lo que puedo concluir que el modelo no esta bien definido.


```{r, fig.width=8,fig.height=8}

ggplot(precioMultiple_resid, aes(.fitted, .resid)) +
  geom_point()+
  geom_hline(yintercept = 0) +
  geom_smooth(se = FALSE)+
    labs(title = "Residuos versus el modelo ajustado", x = "valores fitted", y = "Residuos")

```



Otro caso interesando para estudiar, es si los residuos tienen o no una estructura definida.
Lo que se obseva es una clara estructura en el medio del grafico, esto esta indicando que una parte sistemática del fenómeno que se esta perdiendo, lo cual indica que el modelo no esta funcionando como se esperaria.


### Modelo Logaritmico
### log(price)=β0+β1log(rooms)+β2log(bathrooms)+β3log(surface_covered)+β4property_type+β5barrio+β6surface_patio

```{r}
# banderaDescripcion + sucursalTipo + medicion + banderaDescripcion + pVentasC + mCuadradoC
preciosModelo_log                    = preciosModelo
preciosModelo_log$precio             = log(preciosModelo_log$precio)
preciosModelo_log$medicion           = log(preciosModelo_log$medicion)

lm_precioMultiple_log = lm(precio ~ banderaDescripcion + sucursalTipo + medicion  + pVentasC + mCuadradoC , data=preciosModelo_log)


```

```{r}
summary(lm_precioMultiple_log)
```

```{r}
lm_precioMultiple_log_resid = augment(lm_precioMultiple_log)
lm_precioMultiple_log_resid
```

```{r}
mean(lm_precioMultiple_log_resid$.resid)
```

```{r, fig.width=8,fig.height=8}
ggplot(lm_precioMultiple_log_resid, aes(lm_precioMultiple_log_resid$.resid)) + 
  geom_freqpoly(binwidth = 2.5)+
  labs(fill = "propiedades_resid$.resid", title = "Poligono de frecuencia de los residuos", x = "Residuo", y = "count")
```



```{r, fig.width=8,fig.height=8}
ggplot(lm_precioMultiple_log_resid, aes(sample= .std.resid))+
  stat_qq()+
  geom_abline()+
  labs(title = "Normal QQ plot log", x = "Valores teóricos", y = "Residuos estandarizados")

```

Lo que se obsera en este grafico, es que si bien en los extremos la tendencia es alejarse de la recta, los valores estan mucho mas pegados a ella que en el modelo anterior, lo mismo ocurre con los valores intermedios que estan practicamente sobre la recta. Por lo antes explicado, este modelo esta mejor definido que el anterior.



```{r, fig.width=8,fig.height=8}
ggplot(lm_precioMultiple_log_resid, aes(.fitted, .resid)) +
  geom_point()+
  geom_hline(yintercept = 0) +
  geom_smooth(se = FALSE)+
    labs(title = "Residuos versus el modelo ajustado log", x = "valores fitted", y = "Residuos")

```

Si bien en este caso la diferencia no es tan notoria como en el analisis anterior, se puede apreciar que los residuos no estan formando una figura tan concentrada con en el caso no logaritmico, dando una mejora al modelo en este caso. Repasando el articulo sobre la aplicacion de logaritmos para el estudio, este nuevo modelo con logaritmos podria considerarse un hibrido entre un modelo log-nivel para las covariables que no se modificaron y un modelo log-log para aquellas que si lo fueron.


### Coeficientes estimados y sus p-valores asociados

```{r, fig.width=8,fig.height=8}

lineal_coef= lm_precioMultiple %>% tidy(conf.int=TRUE)
lineal_coef_log= lm_precioMultiple_log %>% tidy(conf.int=TRUE)

ggplot(lineal_coef, aes(term, estimate))+
  geom_point()+
  geom_pointrange(aes(ymin = conf.low, ymax = conf.high))+
  labs(title = "Coeficientes de la regresion lineal", x="", y="Estimacion e Int. Confianza") +
  theme_bw() +
  theme(axis.text.x = element_text(angle=90))

ggplot(lineal_coef_log, aes(term, estimate))+
  geom_point()+
  geom_pointrange(aes(ymin = conf.low, ymax = conf.high))+
  labs(title = "Coeficientes de la regresion lineal log", x="", y="Estimacion e Int. Confianza") +
  theme_bw() +
  theme(axis.text.x = element_text(angle=90))

```


### P-Valor de los regresores

```{r, fig.width=8,fig.height=8}
ggplot(lineal_coef, aes(reorder(term, -p.value), p.value, fill=p.value))+
  geom_bar(stat = 'identity', aes(fill=p.value))+
  geom_hline(yintercept = 0.05) +
  labs(title = "P-valor de los regresores para multiple", x="", y="P-valor") +
  theme_bw() +
  theme(axis.text.x = element_text(angle=90)) + 
  scale_fill_gradient2(high='firebrick', low = 'forestgreen', mid='yellow2',midpoint = 0.5 )


ggplot(lineal_coef_log, aes(reorder(term, -p.value), p.value, fill=p.value))+
  geom_bar(stat = 'identity', aes(fill=p.value))+
  geom_hline(yintercept = 0.05) +
  labs(title = "P-valor de los regresores para multiple log", x="", y="P-valor") +
  theme_bw() +
  theme(axis.text.x = element_text(angle=90)) + 
  scale_fill_gradient2(high='firebrick', low = 'forestgreen', mid='yellow2',midpoint = 0.5 )

```

### Evaluacion de ambos modelos

```{r, fig.width=8,fig.height=8}
multiple = lm_precioMultiple %>% glance() %>% select(r.squared, adj.r.squared, p.value) 
multiple_log = lm_precioMultiple_log %>% glance() %>% select(r.squared, adj.r.squared, p.value)
bind_rows(multiple, multiple_log) %>% mutate(modelo= c('multiple', 'multiple_log'))

```

### Ridge: α=0
### Lasso: α=1
### Elastic Net: 0<α<1


```{r, fig.width=8,fig.height=8}
train_test <- preciosModelo %>% resample_partition(c(train=0.7,test=0.3))

precios_train <- train_test$train %>% as_tibble()
precios_test <- train_test$test %>% as_tibble()

```

## Lasso

```{r, fig.width=8,fig.height=8}
# Vector con los salarios
prod_precios = precios_train$precio
# Matriz con los regresores
prod_mtx = model.matrix(precio~ banderaDescripcion + sucursalTipo + medicion + pVentasC + mCuadradoC, data = precios_train)

# Modelo Lasso
lasso.mod=glmnet(x=prod_mtx, # Matriz de regresores
                 y=prod_precios, #Vector de la variable a predecir
                 alpha=1, # Indicador del tipo de regularizacion
                 standardize = F) # Que esta haciendo este parametro?
                 
lasso_coef = lasso.mod %>% tidy()

lasso_coef

```

### Grafico de coeficientes en funcion del lambda
### Grafico de coeficientes en funcion de la norma de penalizacion
```{r, fig.width=8,fig.height=8}
plot(lasso.mod, 'lambda')
plot(lasso.mod)

```

```{r, fig.width=8,fig.height=8}
# Graficos para los valores de lambda en ggplot.

g1=lasso_coef  %>% ggplot(., aes(log(lambda), estimate, group=term, color=term)) + geom_line() + theme_bw()  + theme(legend.position = 'none') +
  labs(title="Lasso con Intercepto",  y="Coeficientes")

g2=lasso_coef %>% filter(term!='(Intercept)') %>% 
  ggplot(., aes(log(lambda), estimate, group=term, color=term)) + geom_line() + theme_bw()  + theme(legend.position = 'none') +
  labs(title="Lasso sin Intercepto", y="Coeficientes")

plot_grid(g1,g2)

```

### Cross Validation para LASSO

```{r, fig.width=8,fig.height=8}
lasso_cv=cv.glmnet(x=prod_mtx,y=prod_precios,alpha=1, standardize = T)
lasso_cv
```

```{r, fig.width=8,fig.height=8}
plot(lasso_cv)

```

El gráfico nos muestra la media del MSE con su limite superior e inferior y la cantidad de varaibles que sobreviven para cada valor de lambda.


```{r, fig.width=8,fig.height=8}
# Información de CV en dataframe con tidy
lasso_cv %>% tidy()

```

```{r, fig.width=8,fig.height=8}
# Lambda minimo y lambda a 1 desvio estandar
lasso_cv %>% glance()

```

```{r, fig.width=8,fig.height=8}
# Selección lambda óptimo
lasso_lambda_opt = lasso_cv$lambda.min

# Entrenamiento modelo óptimo
lasso_opt = glmnet(x=prod_mtx, # Matriz de regresores
                 y=prod_precios, #Vector de la variable a predecir
                 alpha=1, # Indicador del tipo de regularizacion
                 standardize = TRUE,  # Estandarizamos
                 lambda = lasso_lambda_opt)

# Salida estandar
#lasso_opt
# Tidy
lasso_opt %>% tidy()

```


Hay quedado 14 variables explicando el 0.5134 % del deviance.

## RIDGE
### α=0

```{r, fig.width=8,fig.height=8}
#Modelo ridge
ridge.mod=glmnet(x=prod_mtx, # Matriz de regresores
                 y=prod_precios, #Vector de la variable a predecir
                 alpha=0, # Indicador del tipo de regularizacion
                 standardize = TRUE)
#Coeficientes tidy                 
ridge_coef= ridge.mod %>% tidy()

ridge_coef 

```


```{r, fig.width=8,fig.height=8}

plot(ridge.mod, 'lambda')
plot(ridge.mod)


```


```{r, fig.width=8,fig.height=8}

g1=ridge_coef  %>% ggplot(., aes(log(lambda), estimate, group=term, color=term)) + geom_line() + theme_bw()  + theme(legend.position = 'none') +
  labs(title="Ridge con Intercepto",  y="Coeficientes")

g2=ridge_coef %>% filter(term!='(Intercept)') %>% 
  ggplot(., aes(log(lambda), estimate, group=term, color=term)) + geom_line() + theme_bw()  + theme(legend.position = 'none') +
  labs(title="Ridge sin Intercepto", y="Coeficientes")

plot_grid(g1,g2)
```

### Elección lambda óptimo

```{r, fig.width=8,fig.height=8}
ridge_cv=cv.glmnet(x=prod_mtx,y=prod_precios,alpha=0, standardize = T)

```


```{r, fig.width=8,fig.height=8}
plot(ridge_cv)

```


### Seleccion lambda óptimo para crear el modelo final

```{r, fig.width=8,fig.height=8}
# Selección lambda óptimo
ridge_lambda_opt = ridge_cv$lambda.min

# Entrenamiento modelo óptimo
ridge_opt = glmnet(x=prod_mtx, # Matriz de regresores
                 y=prod_precios, #Vector de la variable a predecir
                 alpha=0, # Indicador del tipo de regularizacion
                 standardize = TRUE,  # Estandarizamos
                 lambda = ridge_lambda_opt)

# Salida estandar
#ridge_opt
ridge_opt %>% tidy()

```

## Compracion entre Lasso y Ridge

```{r, fig.width=8,fig.height=8}

ridge_dev = ridge_coef %>% select(lambda, dev.ratio) %>% distinct() %>%
  ggplot(., aes(log(lambda), dev.ratio)) +
  geom_point() +
  geom_line() +
  geom_vline(xintercept = log(ridge_lambda_opt), color='steelblue', size=1.5) +
  labs(title='Ridge: Deviance') +
  theme_bw() 

lasso_dev = lasso_coef %>% select(lambda, dev.ratio) %>% distinct() %>%
  ggplot(., aes(log(lambda), dev.ratio)) +
  geom_point() +
  geom_line() +
  geom_vline(xintercept = log(lasso_lambda_opt), color='firebrick', size=1.5) +
  labs(title='Lasso: Deviance') +
  theme_bw()

plot_grid(ridge_dev, lasso_dev)


```

Compracion de la relación entre el porcentaje de deviance explicada y lambda para los tres tipos de modelos que realizamos



## Compracion Modelos
### ridge_opt , lasso_opt, lm_precioMultiple_log
### precios_train - precios_test

```{r, fig.width=8,fig.height=8}
ridge_opt

eval_results <- function(true, predicted, df) {
  SSE <- sum((predicted - true)^2)
  SST <- sum((true - mean(true))^2)
  R_square <- 1 - SSE / SST
  RMSE = sqrt(SSE/nrow(df))

  
  # Model performance metrics
data.frame(
  RMSE = RMSE,
  Rsquare = R_square
)
  
}


```


```{r, fig.width=8,fig.height=8}
# Prediccion y evaluacion en train data Lasso
predictions_train <- predict(lasso_opt, s = lasso_lambda_opt, newx = prod_mtx)
eval_results(precios_train$precio, predictions_train, precios_train)
# Prediccion y evaluacion en test data Lasso
predictions_test <- predict(lasso_opt, s = lasso_lambda_opt, newx = prod_mtx)
eval_results(precios_test$precio, predictions_test, precios_test)




```


```{r, fig.width=8,fig.height=8}
# Prediction and evaluation on train data Ridge
predictions_train <- predict(ridge_opt, s = ridge_lambda_opt, newx = prod_mtx)
eval_results(precios_train$precio, predictions_train, precios_train)
# Prediccion y evaluacion en test data Ridge
predictions_test <- predict(ridge_opt, s = ridge_lambda_opt, newx = prod_mtx)
eval_results(precios_test$precio, predictions_test, precios_test)

```

```{r, fig.width=8,fig.height=8}


```

